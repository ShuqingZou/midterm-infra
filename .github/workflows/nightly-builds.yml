name: Nightly Build and Deployment

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  create-ec2:
    runs-on: ubuntu-latest
    outputs:
      instance_id: ${{ steps.create.outputs.instance_id }}
      instance_ip: ${{ steps.create.outputs.instance_ip }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Launch temporary EC2 instance
        id: create
        run: |
          INSTANCE_ID=$(aws ec2 run-instances \
            --region ${{ secrets.AWS_REGION }} \
            --image-id ami-04b4f1a9cf54c11d0 \
            --instance-type t3.micro \
            --key-name midterm-key \
            --security-group-ids sg-03a57241aa0650326 \
            --subnet-id subnet-037010f619e30f145 \
            --associate-public-ip-address \
            --query 'Instances[0].InstanceId' \
            --output text)

          echo "Waiting for EC2 instance ($INSTANCE_ID) to get Public DNS..."

          while true; do
            INSTANCE_IP=$(aws ec2 describe-instances \
              --region ${{ secrets.AWS_REGION }} \
              --instance-ids $INSTANCE_ID \
              --query 'Reservations[0].Instances[0].PublicDnsName' \
              --output text)

            if [[ "$INSTANCE_IP" != "None" && "$INSTANCE_IP" != "" ]]; then
              break
            fi

            echo "Waiting for Public DNS..."
            sleep 5
          done

          echo "Instance ID: $INSTANCE_ID"
          echo "Instance IP: $INSTANCE_IP"

          echo "::set-output name=instance_id::$INSTANCE_ID"
          echo "::set-output name=instance_ip::$INSTANCE_IP"

  build-and-test:
    needs: create-ec2
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Source Repo
        uses: actions/checkout@v4
        with:
          repository: ShuqingZou/midterm-source
          token: ${{ secrets.SOURCE_REPO_PAT }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Docker Compose
        run: |
          sudo apt-get update
          sudo apt-get install -y docker-compose

      - name: Build and tag backend Docker image
        run: |
          docker build -t backend-nightly:latest ./backend
          docker save -o backend-nightly.tar backend-nightly:latest

      - name: Build and tag frontend Docker image
        run: |
          docker build -t frontend-nightly:latest ./frontend
          docker save -o frontend-nightly.tar frontend-nightly:latest

      - name: Upload Docker images as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: |
            backend-nightly.tar
            frontend-nightly.tar

      - name: Upload Docker Compose File as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-compose
          path: docker-compose.yml



  smoke-test:
    needs: [create-ec2, build-and-test]
    runs-on: ubuntu-latest

    steps:
      - name: Wait for EC2 to be ready
        run: |
          sleep 60
          

      - name: Download Docker images
        uses: actions/download-artifact@v4
        with:
          name: docker-images

      - name: SCP Docker images to EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ needs.create-ec2.outputs.instance_ip }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          source: "backend-nightly.tar,frontend-nightly.tar"
          target: "/home/ubuntu/docker-images"

      - name: Download Docker Compose File
        uses: actions/download-artifact@v4
        with:
          name: docker-compose

      - name: SCP docker-compose.yml to EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ needs.create-ec2.outputs.instance_ip }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          source: "docker-compose.yml"
          target: "/home/ubuntu/deploy/"

      - name: SSH into EC2 and Prepare Environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.create-ec2.outputs.instance_ip }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          script: |
            echo "üìÅ Ensuring deploy directory exists..."
            mkdir -p /home/ubuntu/deploy

            echo "üîç Checking if docker-compose.yml exists..."
            if [ ! -f "/home/ubuntu/deploy/docker-compose.yml" ]; then
              echo "‚ùå Error: docker-compose.yml not found!"
              exit 1
            fi

            echo "üßπ Checking disk space before cleanup..."
            df -h

            echo "üóëÔ∏è Removing old Docker containers and images..."
            sudo docker system prune -af || true
            sudo docker volume prune -f || true

            echo "üóëÔ∏è Removing unused packages..."
            sudo apt-get autoremove -y
            sudo apt-get clean

            echo "üóëÔ∏è Clearing journal logs..."
            sudo journalctl --vacuum-time=1d || true

            echo "üßπ Checking disk space after cleanup..."
            df -h

            echo "üì¶ Updating system and installing Docker..."
            sudo apt-get update
            sudo apt-get install -y docker.io docker-compose

            echo "üöÄ Ensuring Docker service is running..."
            sudo systemctl start docker
            sudo systemctl enable docker

            echo "üë§ Adding user to Docker group..."
            sudo usermod -aG docker ubuntu

            echo "‚úÖ Checking Docker version..."
            sudo docker --version
            sudo docker-compose --version

            echo "üìù Creating .env file..."
            cat <<EOF > /home/ubuntu/deploy/.env
            REACT_APP_API_URL=http://localhost:8800
            DB_HOST=${{ secrets.DB_HOST }}
            DB_USER=root
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_NAME=test
            DB_PORT=3306
            EOF

            echo "üì¶ Loading Docker images..."
            sudo docker load -i /home/ubuntu/docker-images/backend-nightly.tar || { echo "‚ùå Failed to load backend image!"; exit 1; }
            sudo docker load -i /home/ubuntu/docker-images/frontend-nightly.tar || { echo "‚ùå Failed to load frontend image!"; exit 1; }

            echo "üöÄ Starting Docker containers..."
            cd /home/ubuntu/deploy
            sudo docker-compose --env-file /home/ubuntu/deploy/.env up -d || { echo "‚ùå Docker-compose up failed!"; exit 1; }
            sleep 20 

            echo "üîç Checking running containers..."
            sudo docker ps -a

            echo "‚úÖ Running Smoke Tests..."
            curl -f http://localhost:8800/ || { echo "‚ùå Backend failed!"; exit 1; }
            curl -f http://localhost:8800/books || { echo "‚ùå Books API failed!"; exit 1; }
            curl -f http://localhost:3000/ || { echo "‚ùå Frontend failed!"; exit 1; }

            echo "üéâ Smoke test passed!"



  push-to-ecr:
    needs: smoke-test
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download Docker images
        uses: actions/download-artifact@v4
        with:
          name: docker-images

      - name: Load Docker images
        run: |
          docker load -i backend-nightly.tar
          docker load -i frontend-nightly.tar

      - name: Login to Amazon ECR
        id: login-ecr
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

      - name: Move `latest` to `previous`
        run: |
          set -e

          BACKEND_REPO="bookapp/backend"
          FRONTEND_REPO="bookapp/frontend"

          LATEST_BACKEND_DIGEST=$(aws ecr describe-images --repository-name "$BACKEND_REPO" --query "imageDetails[?contains(imageTags, 'latest')].imageDigest" --output text || echo "")
          LATEST_FRONTEND_DIGEST=$(aws ecr describe-images --repository-name "$FRONTEND_REPO" --query "imageDetails[?contains(imageTags, 'latest')].imageDigest" --output text || echo "")

          # backend
          if [[ -n "$LATEST_BACKEND_DIGEST" ]]; then
            echo "delete previous if exits"
            aws ecr batch-delete-image --repository-name "$BACKEND_REPO" --image-ids imageTag=previous || true

            echo "let latest be previous"
            IMAGE_MANIFEST=$(aws ecr batch-get-image --repository-name "$BACKEND_REPO" --image-ids imageDigest="$LATEST_BACKEND_DIGEST" --query 'images[0].imageManifest' --output text)
            aws ecr put-image --repository-name "$BACKEND_REPO" --image-tag previous --image-manifest "$IMAGE_MANIFEST"

            echo "delete latest tag"
            aws ecr batch-delete-image --repository-name "$BACKEND_REPO" --image-ids imageTag=latest || true
          else
            echo "no latest, skip"
          fi

          # frontend
          if [[ -n "$LATEST_FRONTEND_DIGEST" ]]; then
            echo "delete previous if exits"
            aws ecr batch-delete-image --repository-name "$FRONTEND_REPO" --image-ids imageTag=previous || true

            echo "let latest be previous"
            IMAGE_MANIFEST=$(aws ecr batch-get-image --repository-name "$FRONTEND_REPO" --image-ids imageDigest="$LATEST_FRONTEND_DIGEST" --query 'images[0].imageManifest' --output text)
            aws ecr put-image --repository-name "$FRONTEND_REPO" --image-tag previous --image-manifest "$IMAGE_MANIFEST"

            echo "delete latest tag"
            aws ecr batch-delete-image --repository-name "$FRONTEND_REPO" --image-ids imageTag=latest || true
          else
            echo "no latest, skip"
          fi

      - name: Push new `latest` Image
        run: |
          set -e

          BACKEND_REPO="bookapp/backend"
          FRONTEND_REPO="bookapp/frontend"
          AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          AWS_REGION="${{ secrets.AWS_REGION }}"

          echo "push new latest"

          # backend
          docker tag backend-nightly:latest "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$BACKEND_REPO:latest"
          docker push "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$BACKEND_REPO:latest"

          # frontend
          docker tag frontend-nightly:latest "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$FRONTEND_REPO:latest"
          docker push "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$FRONTEND_REPO:latest"


  deploy-qa:
    needs: push-to-ecr
    runs-on: ubuntu-latest

    steps:
      - name: SSH into QA EC2 and Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.QA_EC2_IP }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          script: |
            echo "Updating system..."
            sudo apt update && sudo apt install -y docker.io docker-compose awscli
            sudo systemctl start docker

            echo "Logging into Amazon ECR..."
            aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | sudo docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
            
            echo "Navigating to deploy directory..."
            cd /home/ubuntu/deploy

            echo "Stopping existing containers..."
            sudo docker-compose down || true

            echo "Pulling latest images..."
            sudo docker-compose pull

            echo "Starting containers..."
            sudo docker-compose up -d

            echo "Waiting for services to start..."
            sleep 20

            echo "Checking running containers..."
            sudo docker ps

            echo "Running API health checks..."
            curl -f http://localhost:8800/ || (echo "Backend failed!" && exit 1)
            curl -f http://localhost:8800/books || (echo "Books API failed!" && exit 1)
            curl -f http://localhost:3000/ || (echo "Frontend failed!" && exit 1)

            echo "Deployment to QA completed successfully!"


  cleanup:
    needs: [ create-ec2, smoke-test, push-to-ecr ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Debug Instance ID before termination
        run: |
          echo "Instance ID: ${{ needs.create-ec2.outputs.instance_id }}"

      - name: Terminate temporary EC2 instance
        run: |
          INSTANCE_ID="${{ needs.create-ec2.outputs.instance_id }}"

          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: No instance ID found. Skipping termination."
            exit 1
          fi

          aws ec2 terminate-instances --region ${{ secrets.AWS_REGION }} --instance-ids $INSTANCE_ID
